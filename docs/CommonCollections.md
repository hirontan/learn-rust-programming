## 8. Common Collections（共通コレクション）

- 標準ライブラリにコレクションと呼ばれる便利なデータ構造がある
- 下記の3つのコレクションについて、この章では説明
  - ベクタ型：可変数の値を並べて格納できる
  - 文字列：`String`
  - ハッシュマップ：値を特定のキーに関連付ける

### ベクタで一連の値を保持する
- `Vec<T>`：ベクタ
  - メモリに値を隣り合わせに並べる単独のデータ構造に2つ以上の値を格納する
  - 同じ型の値しか格納できない
  - 要素のリストがある場合に有用
    - ex) テキストファイルの各行やショッピングカートのアイテムの価格など

##### 新しいベクタを生成する
- `Vec::new`関数：新しい空のベクタを作る
- 新しい空のベクタを精製して、`i32`型を格納
  - 型注釈をつけている
  - コンパイラは値の型を推測するので、型注釈をつける必要はない。
    - 初期値のある`Vec<T>`を精製する方が一般的
```
let v: Vec<i32> = Vec::new();
```

- `vec!`というマクロもある
- 1、2、3という値を持つ新しい`Vec<i32>`を生成
  - 初期値の`i32`値を与えたので、型を推測し、型注釈が不要になった

```
let v = vec![1, 2, 3];
```

##### ベクタを更新する
- 要素を追加
  - `push`メソッドを使用
    - 値を変化させるので、`mut`キーワードが必要
    - 追加した要素が全て`i32`型で、コンパイラはデータから型を推測し、`Vec<i32>`の注釈なし
```
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

##### ベクタのドロップで、要素もドロップ
- ベクタもスコープを抜ければ、解放される

```
{
    let v = vec![1, 2, 3, 4];

    // vで作業をする

} // <- vはここでスコープを抜け、解放される
```

##### ベクタの要素を読む
- ベクタに格納された値を参照する方法は2つある
  - 索引構文
  - `get`メソッド
- インデックス：0から始まる

```
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);
```

- ベクタに要素が含まれない番号の値を使用しようとした時に、 プログラムの振る舞いを選択できる
  - 索引構文：プログラムをパニックさせる
    - プログラムをクラッシュさせたい場合に最適
  - getメソッド：パニックすることなく`None`を返す
    - 大きすぎる値を誤って入力し、プログラムがNone値を得ると、現在ベクタに幾つ要素があるかをユーザに教え、 再度正しい値を入力できる（タイプミスでプログラムをクラッシュをなくせる）


```
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

- 所有権と借用規則を強制し、ベクタの中身へのこの参照や他のいかなる参照も有効である
  - 同一スコープ上では、可変と不変な参照を同時には存在させられない（ルール）
  - 下記では`error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable`
```
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);
```

##### ベクトル内の値の反復処理
- 全要素の反復処理
  - `for`ループ
```
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```

- 各要素への可変な参照を反復可能
  - 参照解除演算子(*)を使用してiの値を参照する必要がある

```
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

##### Enumを使って複数の型を保持する
- ベクタは同じ型の値しか保持できない
- 異なる型の要素を保持する必要性が出てくるユースケースもあり、`enum`を定義して利用する
  - 副次的な利点は、 このベクタではどんな型が許容されるのか明示できること
```
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```
